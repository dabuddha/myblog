{"meta":{"title":"Bazinga","subtitle":"是时候多动动笔，多记录了","description":null,"author":"Hao Jie","url":"http://lioil.thisteam.cn"},"pages":[{"title":"分类","date":"2016-06-05T14:46:55.000Z","updated":"2016-06-05T14:55:56.000Z","comments":false,"path":"categories/index.html","permalink":"http://lioil.thisteam.cn/categories/index.html","excerpt":"","keywords":null,"text":"","raw":null,"content":null},{"title":"","date":"2016-05-18T03:46:24.000Z","updated":"2016-05-18T03:46:24.000Z","comments":false,"path":"tags/index.html","permalink":"http://lioil.thisteam.cn/tags/index.html","excerpt":"","keywords":null,"text":"","raw":null,"content":null}],"posts":[{"title":"在Next主题下使用Algolia搜索","slug":"hexo-next-use-algolia","date":"2016-06-06T15:23:19.000Z","updated":"2016-06-07T03:42:34.000Z","comments":true,"path":"20160606/hexo-next-use-algolia/","link":"","permalink":"http://lioil.thisteam.cn/20160606/hexo-next-use-algolia/","excerpt":"Swiftype悄无声息的就取消了免费模式，新用户注册只能免费试用14天，老用户好像还能继续免费用(好在我下手早╮(╯▽╰)╭ )。未雨绸缪吧，免得哪天我也不能用了，推一个新的第三方搜索—-algolia。","keywords":null,"text":"Swiftype悄无声息的就取消了免费模式，新用户注册只能免费试用14天，老用户好像还能继续免费用(好在我下手早╮(╯▽╰)╭ )。未雨绸缪吧，免得哪天我也不能用了，推一个新的第三方搜索—-algolia。 官网注册1、 官网地址注册帐号。2、 新建一个INDEX如图。3、 来到API-KEYS页面，上面有后面需要的信息（记得还有上面的INDEX名）。 第二步：上传数据到Algolia1、 在Hexo主目录下执行1npm install hexo-algolia --save 2、 在根目录的_config.yml中加入如下配置，使用前边注册成果的数据123456algolia: applicationID: &apos;your applicationID&apos; apiKey: &apos;your apiKey&apos; adminApiKey: &apos;your adminApiKey&apos; indexName: &apos;your indexName&apos; chunkSize: 5000 3、 接着执行，确保提交成功提示1hexo algolia 第三步：修改Hexo主题集成Algolia1、 确保在head.swig文件中加入如下配置，注意改成自己的123456789101112&lt;script type=&quot;text/javascript&quot; id=&quot;hexo.configuration&quot;&gt; var CONFIG = &#123; root: &apos;/&apos;, algolia: &#123; applicationID: &apos;your applicationID&apos;, apiKey: &apos;your apiKey&apos;, indexName: &apos;&apos;your indexName&apos;, hits: &#123;&quot;per_page&quot;:10&#125;, labels: &#123;&quot;input_placeholder&quot;:&quot;搜索...&quot;,&quot;hits_empty&quot;:&quot;未发现与 「$&#123;query&#125;」相关的内容&quot;,&quot;hits_stats&quot;:&quot;$&#123;hits&#125; 条相关条目，使用了 $&#123;time&#125; 毫秒&quot;&#125; &#125; &#125;;&lt;/script&gt; 2、 在主题配置文件_config.yml中加入,作为开启关闭的开关12# Algoliaalgolia: true 以Next为例，修改主题目录下layout/search.swig为：123456789&#123;% if theme.swiftype_key %&#125; &#123;% include &apos;search/swiftype.swig&apos; %&#125;&#123;% elseif theme.tinysou_Key %&#125; &#123;% include &apos;search/tinysou.swig&apos; %&#125;&#123;% elseif config.search.path %&#125; &#123;% include &apos;search/localsearch.swig&apos; %&#125;&#123;% elseif theme.algolia %&#125; &#123;% include &apos;search/algolia.swig&apos; %&#125;&#123;% endif %&#125; 3、 在要搜索的页面加入下面html,Next主题中在layout/_partials/search/中添加algolia.swig文件，写入如下内容：1234567891011121314151617181920&lt;div class=\"site-search\"&gt; &lt;div class=\"algolia-popup popup\"&gt; &lt;div class=\"algolia-search\"&gt; &lt;div class=\"algolia-search-input-icon\"&gt; &lt;i class=\"fa fa-search\"&gt;&lt;/i&gt; &lt;/div&gt; &lt;div class=\"algolia-search-input\" id=\"algolia-search-input\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"algolia-results\"&gt; &lt;div id=\"algolia-stats\"&gt;&lt;/div&gt; &lt;div id=\"algolia-hits\"&gt;&lt;/div&gt; &lt;div id=\"algolia-pagination\" class=\"algolia-pagination\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;span class=\"popup-btn-close\"&gt; &lt;i class=\"fa fa-times-circle\"&gt;&lt;/i&gt; &lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 4、 触发搜索的HTML节点中加入class名为popup-trigger的标签，如下：1&lt;a href=&quot;#&quot; class=&quot;popup-trigger&quot;&gt; Next为例：在layout/_partials/header.swig修改如下（注释位置）：12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;nav class=\"site-nav\"&gt; &#123;% set hasSearch = theme.swiftype_key || theme.tinysou_Key || config.search || theme.algolia %&#125; &lt;!-- 添加algolia判断条件 --&gt; &#123;% if theme.menu %&#125; &lt;ul id=\"menu\" class=\"menu\"&gt; &#123;% for name, path in theme.menu %&#125; &#123;% set itemName = name.toLowerCase() %&#125; &lt;li class=\"menu-item menu-item-&#123;&#123; itemName &#125;&#125;\"&gt; &lt;a href=\"&#123;&#123; url_for(path) &#125;&#125;\" rel=\"section\"&gt; &#123;% if theme.menu_icons.enable %&#125; &lt;i class=\"menu-item-icon fa fa-fw fa-&#123;&#123;theme.menu_icons[itemName] | default('question-circle') | lower &#125;&#125;\"&gt;&lt;/i&gt; &lt;br /&gt; &#123;% endif %&#125; &#123;&#123; __('menu.' + itemName) &#125;&#125; &lt;/a&gt; &lt;/li&gt; &#123;% endfor %&#125; &#123;% if hasSearch %&#125; &lt;li class=\"menu-item menu-item-search\"&gt; &#123;% if theme.swiftype_key %&#125; &lt;a href=\"#\" class=\"st-search-show-outputs\"&gt; &#123;% elseif config.search %&#125; &lt;a href=\"#\" class=\"popup-trigger\"&gt; &lt;!-- 判断algolia --&gt; &#123;% elseif theme.algolia %&#125; &lt;a href=\"#\" class=\"popup-trigger\"&gt; &#123;% endif %&#125; &#123;% if theme.menu_icons.enable %&#125; &lt;i class=\"menu-item-icon fa fa-search fa-fw\"&gt;&lt;/i&gt; &lt;br /&gt; &#123;% endif %&#125; &#123;&#123; __('menu.search') &#125;&#125; &lt;/a&gt; &lt;/li&gt; &#123;% endif %&#125; &lt;/ul&gt; &#123;% endif %&#125; &#123;% if hasSearch %&#125; &lt;div class=\"site-search\"&gt; &#123;% include 'search.swig' %&#125; &lt;/div&gt; &#123;% endif %&#125;&lt;/nav&gt; 5、 需要确保页面包含如下JS代码（可以单独建立一个.swig文件，然后在整体layout的swig文件中加入）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248&lt;script src=\"http://cdn.bootcss.com/instantsearch.js/1.5.1/instantsearch.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt;$(document).ready(function () &#123; var algoliaSettings = CONFIG.algolia; var isAlgoliaSettingsValid = algoliaSettings.applicationID &amp;&amp; algoliaSettings.apiKey &amp;&amp; algoliaSettings.indexName; if (!isAlgoliaSettingsValid) &#123; window.console.error('Algolia Settings are invalid.'); return; &#125; var search = instantsearch(&#123; appId: algoliaSettings.applicationID, apiKey: algoliaSettings.apiKey, indexName: algoliaSettings.indexName, searchFunction: function (helper) &#123; var searchInput = $('#algolia-search-input').find('input'); if (searchInput.val()) &#123; helper.search(); &#125; &#125; &#125;); // Registering Widgets [ instantsearch.widgets.searchBox(&#123; container: '#algolia-search-input', placeholder: algoliaSettings.labels.input_placeholder &#125;), instantsearch.widgets.hits(&#123; container: '#algolia-hits', hitsPerPage: algoliaSettings.hits.per_page || 10, templates: &#123; item: function (data) &#123; return ( '&lt;a href=\"' + CONFIG.root + data.path + '\" class=\"algolia-hit-item-link\"&gt;' + data._highlightResult.title.value + '&lt;/a&gt;' ); &#125;, empty: function (data) &#123; return ( '&lt;div id=\"algolia-hits-empty\"&gt;' + algoliaSettings.labels.hits_empty.replace(/\\$\\&#123;query&#125;/, data.query) + '&lt;/div&gt;' ); &#125; &#125;, cssClasses: &#123; item: 'algolia-hit-item' &#125; &#125;), instantsearch.widgets.stats(&#123; container: '#algolia-stats', templates: &#123; body: function (data) &#123; var stats = algoliaSettings.labels.hits_stats .replace(/\\$\\&#123;hits&#125;/, data.nbHits) .replace(/\\$\\&#123;time&#125;/, data.processingTimeMS); return ( stats + '&lt;span class=\"algolia-powered\"&gt;' + ' &lt;img src=\"' + CONFIG.root + 'images/algolia_logo.svg\" alt=\"Algolia\" /&gt;' + '&lt;/span&gt;' + '&lt;hr /&gt;' ); &#125; &#125; &#125;), instantsearch.widgets.pagination(&#123; container: '#algolia-pagination', scrollTo: false, showFirstLast: false, labels: &#123; first: '&lt;i class=\"fa fa-angle-double-left\"&gt;&lt;/i&gt;', last: '&lt;i class=\"fa fa-angle-double-right\"&gt;&lt;/i&gt;', previous: '&lt;i class=\"fa fa-angle-left\"&gt;&lt;/i&gt;', next: '&lt;i class=\"fa fa-angle-right\"&gt;&lt;/i&gt;' &#125;, cssClasses: &#123; root: 'pagination', item: 'pagination-item', link: 'page-number', active: 'current', disabled: 'disabled-item' &#125; &#125;) ].forEach(search.addWidget, search); search.start(); $('.popup-trigger').on('click', function(e) &#123; e.stopPropagation(); $('body').append('&lt;div class=\"popoverlay\"&gt;').css('overflow', 'hidden'); $('.popup').toggle(); $('#algolia-search-input').find('input').focus(); &#125;); $('.popup-btn-close').click(function()&#123; $('.popup').hide(); $('.popoverlay').remove(); $('body').css('overflow', ''); &#125;);&#125;);&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $(document).ready(function () &#123; if ( $('#local-search-input').size() === 0) &#123; return; &#125; // Popup Window; var isfetched = false; // Search DB path; var search_path = \"search.xml\"; if (search_path.length == 0) &#123; search_path = \"search.xml\"; &#125; var path = \"/\" + search_path; // monitor main search box; function proceedsearch() &#123; $(\"body\").append('&lt;div class=\"popoverlay\"&gt;').css('overflow', 'hidden'); $('.popup').toggle(); &#125; // search function; var searchFunc = function(path, search_id, content_id) &#123; 'use strict'; $.ajax(&#123; url: path, dataType: \"xml\", async: true, success: function( xmlResponse ) &#123; // get the contents from search data isfetched = true; $('.popup').detach().appendTo('.header-inner'); var datas = $( \"entry\", xmlResponse ).map(function() &#123; return &#123; title: $( \"title\", this ).text(), content: $(\"content\",this).text(), url: $( \"url\" , this).text() &#125;; &#125;).get(); var $input = document.getElementById(search_id); var $resultContent = document.getElementById(content_id); $input.addEventListener('input', function()&#123; var matchcounts = 0; var str='&lt;ul class=\\\"search-result-list\\\"&gt;'; var keywords = this.value.trim().toLowerCase().split(/[\\s\\-]+/); $resultContent.innerHTML = \"\"; if (this.value.trim().length &gt; 1) &#123; // perform local searching datas.forEach(function(data) &#123; var isMatch = true; var content_index = []; var data_title = data.title.trim().toLowerCase(); var data_content = data.content.trim().replace(/&lt;[^&gt;]+&gt;/g,\"\").toLowerCase(); var data_url = data.url; var index_title = -1; var index_content = -1; var first_occur = -1; // only match artiles with not empty titles and contents if(data_title != '' &amp;&amp; data_content != '') &#123; keywords.forEach(function(keyword, i) &#123; index_title = data_title.indexOf(keyword); index_content = data_content.indexOf(keyword); if( index_title &lt; 0 &amp;&amp; index_content &lt; 0 )&#123; isMatch = false; &#125; else &#123; if (index_content &lt; 0) &#123; index_content = 0; &#125; if (i == 0) &#123; first_occur = index_content; &#125; &#125; &#125;); &#125; // show search results if (isMatch) &#123; matchcounts += 1; str += \"&lt;li&gt;&lt;a href='\"+ data_url +\"' class='search-result-title'&gt;\"+ data_title +\"&lt;/a&gt;\"; var content = data.content.trim().replace(/&lt;[^&gt;]+&gt;/g,\"\"); if (first_occur &gt;= 0) &#123; // cut out 100 characters var start = first_occur - 20; var end = first_occur + 80; if(start &lt; 0)&#123; start = 0; &#125; if(start == 0)&#123; end = 50; &#125; if(end &gt; content.length)&#123; end = content.length; &#125; var match_content = content.substring(start, end); // highlight all keywords keywords.forEach(function(keyword)&#123; var regS = new RegExp(keyword, \"gi\"); match_content = match_content.replace(regS, \"&lt;b class=\\\"search-keyword\\\"&gt;\"+keyword+\"&lt;/b&gt;\"); &#125;); str += \"&lt;p class=\\\"search-result\\\"&gt;\" + match_content +\"...&lt;/p&gt;\" &#125; str += \"&lt;/li&gt;\"; &#125; &#125;)&#125;; str += \"&lt;/ul&gt;\"; if (matchcounts == 0) &#123; str = '&lt;div id=\"no-result\"&gt;&lt;i class=\"fa fa-frown-o fa-5x\" /&gt;&lt;/div&gt;' &#125; if (keywords == \"\") &#123; str = '&lt;div id=\"no-result\"&gt;&lt;i class=\"fa fa-search fa-5x\" /&gt;&lt;/div&gt;' &#125; $resultContent.innerHTML = str; &#125;); proceedsearch(); &#125; &#125;);&#125; // handle and trigger popup window; $('.popup-trigger').mousedown(function(e) &#123; e.stopPropagation(); if (isfetched == false) &#123; searchFunc(path, 'local-search-input', 'local-search-result'); &#125; else &#123; proceedsearch(); &#125;; &#125;); $('.popup-btn-close').click(function(e)&#123; $('.popup').hide(); $(\".popoverlay\").remove(); $('body').css('overflow', ''); &#125;); $('.popup').click(function(e)&#123; e.stopPropagation(); &#125;); &#125;);&lt;/script&gt; Next中可以新建一个js文件，myalgolia.js存放上述代码，然后存入主题的source/js/src中，然后修改主题的layout/_layout.swig,添加如下内容：123&#123;% if theme.algolia %&#125; &#123;% include &apos;_scripts/algolia.swig&apos; %&#125;&#123;% endif %&#125; 然后在layout/_scripts中新建algolia.swig，内容如下：12345678910&#123;% set js_algolia = [ &apos;src/myalgolia.js&apos; ]%&#125;&#123;% for common in js_algolia %&#125; &lt;script type=&quot;text/javascript&quot; src=&quot;&#123;&#123; url_for(theme.js) &#125;&#125;/&#123;&#123; common &#125;&#125;?v=&#123;&#123; theme.version &#125;&#125;&quot;&gt;&lt;/script&gt;&#123;% endfor %&#125; &lt;script src=&quot;http://cdn.bootcss.com/instantsearch.js/1.5.1/instantsearch.js&quot;&gt;&lt;/script&gt; 6、确保要搜索页包含如下CSS代码（可以单独建立一个.styl文件，然后在整体css的styl文件中加入，注意确保生成正确，必要时可以执行hexo clean）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215ul.search-result-list &#123; padding-left: 0px; margin: 0px 5px 0px 8px;&#125;p.search-result &#123; border-bottom: 1px dashed #ccc; padding: 5px 0;&#125;a.search-result-title &#123; font-weight: bold;&#125;a.search-result &#123; border-bottom: transparent; display: block; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;&#125;.search-keyword &#123; border-bottom: 1px dashed #4088b8; font-weight: bold;&#125;#local-search-result &#123; height: 90%; overflow: auto;&#125;.popup &#123; display: none; position: fixed; top: 10%; left: 50%; width: 700px; height: 80%; margin-left: -350px; padding: 3px 0 0 10px; background: #fff; color: #333; z-index: 9999; border-radius: 5px;&#125;@media (max-width: 767px) &#123; .popup &#123; padding: 3px; top: 0; left: 0; margin: 0; width: 100%; height: 100%; border-radius: 0px; &#125;&#125;.popoverlay &#123; position: fixed; width: 100%; height: 100%; top: 0px; left: 0px; z-index: 2080; background-color: rgba(0,0,0,0.3);&#125;#local-search-input &#123; margin-bottom: 10px; width: 50%;&#125;.popup-btn-close &#123; position: absolute; top: 6px; right: 14px; color: #4ebd79; font-size: 14px; font-weight: bold; text-transform: uppercase; cursor: pointer;&#125;#no-result &#123; position: absolute; left: 44%; top: 42%; color: #ccc;&#125;.busuanzi-count:before &#123; content: \" \"; float: left; width: 260px; min-height: 25px;&#125;@media (min-width: 768px) and (max-width: 991px) &#123; .busuanzi-count &#123; width: auto; &#125; .busuanzi-count:before &#123; display: none; &#125;&#125;@media (max-width: 767px) &#123; .busuanzi-count &#123; width: auto; &#125; .busuanzi-count:before &#123; display: none; &#125;&#125;.site-uv,.site-pv,.page-pv &#123; display: inline-block;&#125;.site-uv .busuanzi-value,.site-pv .busuanzi-value,.page-pv .busuanzi-value &#123; margin: 0 5px;&#125;.site-uv &#123; margin-right: 10px;&#125;.site-uv::after &#123; content: \"|\"; padding-left: 10px;&#125;.algolia-popup &#123; overflow: hidden; padding: 0;&#125;.algolia-popup .popup-btn-close &#123; padding-left: 15px; border-left: 1px solid #eee; top: 10px;&#125;.algolia-popup .popup-btn-close .fa &#123; color: #999; font-size: 18px;&#125;.algolia-popup .popup-btn-close:hover .fa &#123; color: #222;&#125;.algolia-search &#123; padding: 10px 15px 5px; max-height: 50px; border-bottom: 1px solid #ccc; background: #f5f5f5; border-top-left-radius: 5px; border-top-right-radius: 5px;&#125;.algolia-search-input-icon &#123; display: inline-block; width: 20px;&#125;.algolia-search-input-icon .fa &#123; font-size: 18px;&#125;.algolia-search-input &#123; display: inline-block; width: calc(90% - 20px);&#125;.algolia-search-input input &#123; padding: 5px 0; width: 100%; outline: none; border: none; background: transparent;&#125;.algolia-powered &#123; float: right;&#125;.algolia-powered img &#123; display: inline-block; height: 18px; vertical-align: middle;&#125;.algolia-results &#123; position: relative; overflow: auto; padding: 10px 30px; height: calc(100% - 50px);&#125;.algolia-results hr &#123; margin: 10px 0;&#125;.algolia-results .highlight &#123; font-style: normal; margin: 0; padding: 0 2px; font-size: inherit; color: #f00;&#125;.algolia-hits &#123; margin-top: 20px;&#125;.algolia-hit-item &#123; margin: 15px 0;&#125;.algolia-hit-item-link &#123; display: block; border-bottom: 1px dashed #ccc; transition-duration: 0.2s; transition-timing-function: ease-in-out; transition-delay: 0s;&#125;.algolia-pagination .pagination &#123; margin-top: 40px; border-top: none; padding: 0;&#125;.algolia-pagination .pagination-item &#123; display: inline-block;&#125;.algolia-pagination .page-number &#123; border-top: none;&#125;.algolia-pagination .page-number:hover &#123; border-bottom: 1px solid #222;&#125;.algolia-pagination .disabled-item &#123; visibility: hidden;&#125; 7、将如下图片放入主题的source/images下 大功告成~，可以参考本站搜索功能。 写作时参考《Hexo集成Algolia搜索插件》","raw":null,"content":null,"categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://lioil.thisteam.cn/categories/Hexo/"}],"tags":[{"name":"Algolia","slug":"Algolia","permalink":"http://lioil.thisteam.cn/tags/Algolia/"},{"name":"Next","slug":"Next","permalink":"http://lioil.thisteam.cn/tags/Next/"},{"name":"swiftype","slug":"swiftype","permalink":"http://lioil.thisteam.cn/tags/swiftype/"}]},{"title":"js数组去重","slug":"array-remove-duplicates","date":"2016-06-05T12:57:53.000Z","updated":"2016-06-05T15:34:57.000Z","comments":true,"path":"20160605/array-remove-duplicates/","link":"","permalink":"http://lioil.thisteam.cn/20160605/array-remove-duplicates/","excerpt":"最简洁12345//利用Array.filtervar arr = [\"1\", \"2\", \"3\", \"1\", \"3\"];arr = arr.filter( function( item, index, inputArray ) &#123; return inputArray.indexOf(item) == index; &#125;);//Output: [\"1\", \"2\", \"3\"] 这个写法相对简洁，但是并不怎么效率O(n^2)，不适合过长的数组。","keywords":null,"text":"最简洁12345//利用Array.filtervar arr = [\"1\", \"2\", \"3\", \"1\", \"3\"];arr = arr.filter( function( item, index, inputArray ) &#123; return inputArray.indexOf(item) == index; &#125;);//Output: [\"1\", \"2\", \"3\"] 这个写法相对简洁，但是并不怎么效率O(n^2)，不适合过长的数组。 改进版123456function uniq(a) &#123; var seen = &#123;&#125;; return arr.filter(function(item) &#123; return seen.hasOwnProperty(item) ? false : (seen[item] = true); &#125;);&#125; 这个写法比上一个效率得多，时间复杂度O(n),但是有两个缺陷： 对于Number和String来说，该算法不能区分，比如： 1uniq([1,\"1\",2,\"2\"])//返回[1, 2] 同理，对于对象来说也不能区分，所有对象都被认为相等。所以使用时要明确使用场景。 1uniq([&#123;foo:1&#125;,&#123;foo:2&#125;])//返回[&#123;foo:1&#125;] 最终版1234567891011function uniq(a) &#123; var prims = &#123;\"boolean\":&#123;&#125;, \"number\":&#123;&#125;, \"string\":&#123;&#125;&#125;, objs = []; return a.filter(function(item) &#123; var type = typeof item; if(type in prims) return prims[type].hasOwnProperty(item) ? false : (prims[type][item] = true); else return objs.indexOf(item) &gt;= 0 ? false : objs.push(item); &#125;);&#125; ES6版本ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。这样我们的去重的思路可以变为，将数组转化为集合，再由集合转化为数组。1[...new Set(arr)] 配合babel之后，这行代码应该是真正的终极版。","raw":null,"content":null,"categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://lioil.thisteam.cn/categories/Javascript/"}],"tags":[{"name":"数组去重","slug":"数组去重","permalink":"http://lioil.thisteam.cn/tags/数组去重/"}]},{"title":"移动端safari上jQuery绑定click事件的bug","slug":"safari-jquery-on-click-bug","date":"2016-05-31T16:49:36.000Z","updated":"2016-06-06T15:28:14.000Z","comments":true,"path":"20160601/safari-jquery-on-click-bug/","link":"","permalink":"http://lioil.thisteam.cn/20160601/safari-jquery-on-click-bug/","excerpt":"之前网站适配pc端的时候发现，在手机端safari上click事件各种没反应，查了一圈看来是有这么个bug。html如下：1234567&lt;div id=\"main\"&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; js代码如下：123$('body').on('click','li',function()&#123; console.log('blink!');&#125;); 如上代码在iOS的safari上毫无反应。","keywords":null,"text":"之前网站适配pc端的时候发现，在手机端safari上click事件各种没反应，查了一圈看来是有这么个bug。html如下：1234567&lt;div id=\"main\"&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; js代码如下：123$('body').on('click','li',function()&#123; console.log('blink!');&#125;); 如上代码在iOS的safari上毫无反应。几个解决方法： 不将on作用于document或者body上，作用在更小的dom节点上，比如，如下代码是生效的： 123$('#main').on('click','li',function()&#123; console.log('blink!');&#125;); 也可以额外在节点上再绑一次事件（添加到代码中）： 123$('body').children().click(function()&#123; //此处什么也不做&#125;); 还有不太优雅的方法，可以再元素标签上添加一个onclick=&#39;&#39;。 在和用户体验不冲突的情况下也可以用CSS解决，给需要响应click事件的标签添加cursor:pointer;","raw":null,"content":null,"categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://lioil.thisteam.cn/categories/Javascript/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://lioil.thisteam.cn/tags/iOS/"},{"name":"jQuery","slug":"jQuery","permalink":"http://lioil.thisteam.cn/tags/jQuery/"},{"name":"Safari","slug":"Safari","permalink":"http://lioil.thisteam.cn/tags/Safari/"}]},{"title":"MAC批量处理图片","slug":"MAC批量处理图片","date":"2016-05-30T09:19:38.000Z","updated":"2016-06-05T14:46:26.000Z","comments":true,"path":"20160530/MAC批量处理图片/","link":"","permalink":"http://lioil.thisteam.cn/20160530/MAC批量处理图片/","excerpt":"","keywords":null,"text":"最近有个批量改图片尺寸的活，打开photoshop做批处理真心觉得累。搜罗了一圈，发现mac有个命令———sips。再输入如下命令之后：1sips --help 修改尺寸的就是下面的几个用法。\u000e1234-z, --resampleHeightWidth pixelsH pixelsW --resampleWidth pixelsW --resampleHeight pixelsH-Z, --resampleHeightWidthMax pixelsWH 例如：123sips -z 100 200 img.jpg //z为小写，100、200分别是是img.jpg的宽、高sips -Z 200 img.jpg //Z为大写, 200为img.jpg的最大宽高sips -Z 200 *.jpg //处理该路径下的所有.jpg文件，最大宽高为200","raw":null,"content":null,"categories":[{"name":"Tips","slug":"Tips","permalink":"http://lioil.thisteam.cn/categories/Tips/"}],"tags":[{"name":"MAC","slug":"MAC","permalink":"http://lioil.thisteam.cn/tags/MAC/"},{"name":"图片处理","slug":"图片处理","permalink":"http://lioil.thisteam.cn/tags/图片处理/"}]},{"title":"利用Git Hooks自动化开发和部署","slug":"git-hooks","date":"2016-05-18T07:28:25.000Z","updated":"2016-06-05T14:46:08.000Z","comments":true,"path":"20160518/git-hooks/","link":"","permalink":"http://lioil.thisteam.cn/20160518/git-hooks/","excerpt":"翻译自How To Use Git Hooks To Automate Development and Deployment Tasks 介绍版本控制在现代软件开发中变成了一个核心的要求。它使得项目可以安全的记录变更，恢复，完整性检查，多人协作等等。git在这些年里被广泛的接纳，得益于其分布式的架构和它在向各方传递变更的速度。 虽然git的工具套件提供了很多现成的特性，其中最实用的就是它的灵活性。通过对钩子系统的使用，git允许开发者或者管理员通过让git根据不同的events和actions的触发来运行自己的脚本，从而对git的功能进行扩展。 这篇文章中，我会介绍git钩子的原理和如何实现自动化任务。我们将会使用Ubuntu 14.04，不过所有系统运行git都大同小异。","keywords":null,"text":"翻译自How To Use Git Hooks To Automate Development and Deployment Tasks 介绍版本控制在现代软件开发中变成了一个核心的要求。它使得项目可以安全的记录变更，恢复，完整性检查，多人协作等等。git在这些年里被广泛的接纳，得益于其分布式的架构和它在向各方传递变更的速度。 虽然git的工具套件提供了很多现成的特性，其中最实用的就是它的灵活性。通过对钩子系统的使用，git允许开发者或者管理员通过让git根据不同的events和actions的触发来运行自己的脚本，从而对git的功能进行扩展。 这篇文章中，我会介绍git钩子的原理和如何实现自动化任务。我们将会使用Ubuntu 14.04，不过所有系统运行git都大同小异。 准备工作开始之前，你需要先在你的运行环境中安装好git。你可以参考这篇教程Ubuntu14.04安装git。 你应该简要了解git的使用。如果你需要入门，可以看看这个教程Git介绍：安装，使用，分支 如果上边的都没有问题，继续往下看。 Git Hooks的基本原理Git Hooks是一个相当简单的概念，它为了满足特定的需求。当开发者开发一个协作的项目，维护代码风格，或者部署项目（这些都是使用git常见的情况）时，经常有有些重复性任务在每次完成一个动作时都要执行。 Git钩子是基于事件的。当你运行了特定的git命令，git会检查git仓库中hooks路径下有没有相关脚本要执行。 有的脚本在git指令之前执行，这可以用来确保代码的完整（进行一些完整性检查）或者提前部署一下环境。那些在git事件之后执行的脚本，一般就是用来部署代码，重新建立权限（一些git不能很好记录的事情）等等。 使用git的这些功能，就可以强制实施策略，确保一致性，和控制你的环境，甚至处理部署任务。 Scott Chacon写的Pro Git这本书试图将钩子归类，他是这样写的： 客户端钩子：在提交者计算机上被调用和执行的钩子。这些可以进一步分为一些小的类别： 提交工作流钩子：提交钩子是用来检测那些需要在提交的前后需要执行的动作。他们可以用来运行完整性检查,预填充提交信息和验证消息详情。你也可以基于提交来推送通知。 邮件工作流的钩子：这一类的钩子包含了当你使用邮件补丁时触发的动作。类似Linux内核提交和通过邮件方法回看补丁。这些都和提交钩子是一样的，但是邮件钩子可以被负责申请提交代码的管理员所使用。 其它：其它客户端钩子包括那些在merge,check out,rebase,rewrite,clean时执行的钩子。 服务端钩子：这些钩子在那些用来接收推送代码的服务器上执行。通常，这就是项目的主要git仓库。同样，Chacon也把这些细分成一下几类。 pre-receive和post-receive: 这两个在服务器收到push操作时执行，比如检查项目一致性和在push之后立即部署项目。 update:这个和pre-receive很像，但是它是一个分支接着一个分支的运作的基础上,在每个分支被更新之前执行。 这些分类能使我们对可以建立钩子的事件有了一个大体的认识。但是为了确切了解他们是怎么运作的，最好还是亲身试验来找出你想要实现的方案。 某些钩子还需要参数。这意味着，当git为某个钩子调用脚本，它会传入脚本会用到的一些相关的数据，以便完成相应的任务。所有的hooks如下表所示。 Hook 名称 触发命令 描述 参数（数量和描述） applypatch-msg git am 可以编辑提交信息，常用于验证或者标准化补丁信息。非零状态会放弃这次提交 1个参数，包含被建议提交信息的临时文件名 pre-applypatch git am 在补丁被运用之后，但是提交之前运行。非零退出，修改仍为未提交状态。可以用来在正式提交之前检查状态树 无 post-applypatch git am 这个钩子在补丁应用和提交之后运行。因此它无法阻止打补丁的过程，主要用于创建通知。 无 pre-commit git commit 这个钩子在获取提交信息之前运行。返回非零值时放弃此次提交，它是用来检查提交本身(而不是提交信息） 无 prepare-commit-msg git commit 在接受到默认提交信息之后，在提交信息编辑器显示之前运行。返回非零值退出，放弃这次提交。它可以用来以一种不可被取消的方式编辑信息。 (1到3个参数)文件名连同提交信息，原始提交信息（message,template,merge,squash,commit),和提交的SHA-1校验和(当对已有信息进行操作时)。 commit-msg git commit 可以被用来在信息被编辑之后调整信息，以便确保它符合标准，或者依照标准驳回此信息。如果该hook脚本以非零退出，Git放弃提交。 1个参数，存放提交信息的文件。 post-commit git commit 在整个提交过程完成后运行。因此，它不能中断提交。这个hook主要用来允许通知。 无 pre-rebase git rebase 当rebase一个分支的时候执行。主要用于在不可取的时候中止rebase。 (1到2个参数)上游分支的节点，需要被rebase的分支(在rebase分支为当前时不设置) post-checkout git checkout和git clone 在更新工作树之后执行checkout或者clone之后运行。它主要用于验证状态，展示区别和在必要时配置环境。 (3个参数)之前HEAD的引用，新HEAD的引用，是否为一个检出的分支的标记。（1个参数）或者一个检出的文件（0） post-merge git merge或git pull 在merge之后执行。因此，它不能中止merge操作，它可以用来存储或者申请权限或者其他不属于git的数据。 (1个参数)merge是否为squash的标记。 pre-push git push 在push到远程服务器之前执行。再加上参数，额外的信息，以&lt;本地ref&gt; &lt;本地sha1&gt; &lt;远程ref&gt; &lt;远程sha1&gt;的形式。解析输入可以获得可以用来检验的额外信息。比如说，如果local sha1是40个零的长度，push是一个删除操作，如果remote sha1是40个零，那么它是一个新的分支。这个特性可以将已经提交的refs和当前状况做很多比较。非零退出，将会中止这次提交。 (2个参数)远程地址名称，远程地址 pre-receive 远程仓库git-receive-pack 在更新提交的refs之前，在远程仓库上运行。非零的状态中止。虽然不接受参数，它为每一个ref传递一个标准输入的字符串，以&lt;旧的值&gt; &lt;新的值&gt; &lt;ref的名称&gt;的形式。 无 update 远程仓库git-receive-pack 在远程仓库上，每一个ref被提交运行一次，而不是每次提交都运行。非零的状态会中止。这可以用来确保所有的提交都只用fast forward模式 (三个参数)被更新的ref名称，旧的对象名，新的对象名。 post-receive 远程仓库git-receive-pack 在所有的ref更新后运行。不需要参数，但是通过标准输入接受信息，格式为&lt;旧的值&gt; &lt;新的值&gt; &lt;ref的名称&gt;。因为在更新后运行，所以不能被中止。 无 post-update 远程仓库git-receive-pack 在所有的refs都已经被push之后只运行一次。它在这方面和post-receive很相似，但是不接受之前和之后的值。它主要用来根据被推送的refs实现通知。 每一个被推送的包含它名字的refs。 pre-auto-gc git gc --auto 在clean仓库之前自动做一些检查 无 post-rewrite git commit --amend,git-rebase 当git命令重写已经提交的数据时执行。除了接受的参数，它还以&lt;旧sha1&gt;&lt;新sha1&gt;的格式接受标准输入的字符串。 (1个参数)触发这个钩子的命令名称(amend或者rebase) 现在你已经有了大体的概念，我们可以在几个场景下试验一下。 建立一个仓库一开始，我们需要先建立一个新的空仓库，在我们的主目录下。我们可以给它命名为proj。 123mkdir ~/projcd ~/projgit init 1Initialized empty Git repository in /home/demo/proj/.git/ 现在，我们在这个在git控制下的空目录内。在我们开始之前，我们先看看目录中的隐藏文件，它们在.git目录下：12cd .gitls -F 1branches/ config description HEAD hooks/ info/ objects/ refs/ 我们可以看到一些文件和目录。我们感兴趣的就是这个hooks目录：12cd hooksls -l 12345678910total 40-rwxrwxr-x 1 demo demo 452 Aug 8 16:50 applypatch-msg.sample-rwxrwxr-x 1 demo demo 896 Aug 8 16:50 commit-msg.sample-rwxrwxr-x 1 demo demo 189 Aug 8 16:50 post-update.sample-rwxrwxr-x 1 demo demo 398 Aug 8 16:50 pre-applypatch.sample-rwxrwxr-x 1 demo demo 1642 Aug 8 16:50 pre-commit.sample-rwxrwxr-x 1 demo demo 1239 Aug 8 16:50 prepare-commit-msg.sample-rwxrwxr-x 1 demo demo 1352 Aug 8 16:50 pre-push.sample-rwxrwxr-x 1 demo demo 4898 Aug 8 16:50 pre-rebase.sample-rwxrwxr-x 1 demo demo 3611 Aug 8 16:50 update.sample 在这儿，我们可以看到。首先，每一个文件都标记成了可执行。因为这些脚本都是按照名称执行的，他们必须是可执行的，而且它们的第一行必须是Shebang(#!)#Magic_number)指向正确的脚本解释器。比较常见的是bash，perl，python等。 你还会注意到的是，所有文件都是以.sample结尾的。这是因为git只是简单的看文件名来查找要执行的hook文件。文件名和git想要查找的出现偏差，这样可以达到禁用的目的。想启用任意一个脚本，只需要去掉结尾的.sample后缀。 让我们退回到我们的工作目录。1cd ../.. 第一个例子：用一个post-commit Hook来部署一个web服务。我们第一个例子，使用post-commithook来展示，如何在每一次提交之后在本地web服务器中部署代码。这不是在生产环境中使用的hook，但是可以让你验证一些重要的，文档里没怎么体现的东西，他们是你在使用hooks的时候应该知道的。 首先，我们安装一个Apache web server。 12sudo apt-get updatesudo apt-get install apache2 为了让我们的脚本可以修改web根目录/var/www/html(这是Ubuntu14.04的文档根目录。可以按需修改)，我们需要有写权限。我们给我们的普通用户这个目录的所有权。输入以下命令：1sudo chown -R `whoami`:`id -gn` /var/www/html 现在，在我们的项目根目录下，创建index.html文件12cd ~/projnano index.html 在文件中，我们添加一小段HTML主要用做论证我们的观点。不用太复杂：12&lt;h1&gt;Here is a title!&lt;/h1&gt;&lt;p&gt;Please deploy me!&lt;/p&gt; 添加这个文件到git：1git add . 在提交之前，我们将要为这个仓库建立我们的post-commit钩子。在.git/hooks中创建文件1vim .git/hooks/post-commit 在我们在文件中添加脚本之前，我们需要知道git在运行钩子时如何建立环境。 关于git钩子环境变量的一些题外话在我们开始写脚本之前，我们需要知道git钩子运行时建立的环境变量。为了让我们的脚本工作，我们最终需要解除一个git调用post-commit钩子时设置的环境变量。 如果你希望写一个运行稳定的git钩子，你需要先理解一个很重要的知识点。git根据你调用哪个钩子来建立不同的环境变量。这意味着git获取信息的环境会根据钩子的不同而不同。 第一个状况是，会使得你的脚本运行环境不可预测，如果你不知道哪个变量被自动设置了。第二个状况就是那个被设置的变量在git自身的文档里几乎没有体现。 幸运的是，Mark Longair开发了当运行钩子时检测git设置的每一个变量的方法。它涉及到在git钩子脚本中添加下列内容：1234#!/bin/bashecho Running $BASH_SOURCEset | egrep GITecho PWD is $PWD 他的篇文章是2011年写的，当时git的版本是1.7.1，所以现在已经有了一些变化。我的这篇文章是2014年8月写的，当前git版本是1.9.1。 在此git版本下的测试结果如下（包括工作目录）。测试用的本地工作目录为/home/demo/test_hooks和一个裸的远程仓库/home/demo/origin/test_hooks.git: 钩子：applypatch-msg, pre-applypatch, post-applypatch 环境变量： GIT_AUTHOR_DATE=&#39;Mon, 11 Aug 2014 11:25:16 -0400&#39; GIT_AUTHOR_EMAIL=demo@example.com GIT_AUTHOR_NAME=&#39;Demo User&#39; GIT_INTERNAL_GETTEXT_SH_SCHEME=gnu GIT_REFLOG_ACTION=am 工作目录：/home/demo/test_hooks 钩子：pre-commit, prepare-commit-msg, commit-msg, post-commit 环境变量： GIT_AUTHOR_DATE=&#39;@1407774159 -0400&#39; GIT_AUTHOR_EMAIL=demo@example.com GIT_AUTHOR_NAME=&#39;Demo User&#39; GIT_DIR=.git GIT_EDITOR=: GIT_INDEX_FILE=.git/index GIT_PREFIX= 工作目录：/home/demo/test_hooks 钩子：pre-rebase 环境变量： GIT_INTERNAL_GETTEXT_SH_SCHEME=gnu GIT_REFLOG_ACTION=rebase 工作目录：/home/demo/test_hooks 钩子：post-checkout 环境变量： GIT_DIR=.git GIT_PREFIX= 工作目录：/home/demo/test_hooks 钩子：post-merge 环境变量： GITHEAD_4b407c... GIT_DIR=.git GIT_INTERNAL_GETTEXT_SH_SCHEME=gnu GIT_PREFIX= GIT_REFLOG_ACTION=&#39;pull other master&#39; 工作目录：/home/demo/test_hooks 钩子：pre-push 环境变量： GIT_PREFIX= 工作目录：/home/demo/test_hooks 钩子：pre-receive·, update, post-receive, post-update 环境变量： GIT_DIR=. 工作目录：/home/demo/origin/test_hooks.git 钩子：pre-auto-gc (未知，因为这个钩子很难可靠地触发) 钩子：post-rewrite 环境变量： GIT_AUTHOR_DATE=&#39;@1407773551 -0400&#39; GIT_AUTHOR_EMAIL=demo@example.com GIT_AUTHOR_NAME=&#39;Demo User&#39; GIT_DIR=.git GIT_PREFIX= 工作目录：/home/demo/test_hooks 这些变量暗示了git如何查看自己的环境。我们将利用上述关于变量的信息来确保我们的脚本正确考虑了它的环境。 回到脚本现在你对所需的环境有了一定概念（看一下为post-commit钩子所设置的变量），我们可以开始我们的脚本了。 由于git钩子是标准脚本，我们需要告诉git，我们用什么解释器：1#!/bin/bash 在这个之后，我们只要在提交后使用git取出最新版本的仓库，放到web目录下。要完成这件事儿，我们需要把我们的工作目录设置到apache的文件根目录。我们也需要把我们的git目录设置为仓库的地址。 我们想要强制操作来保证每一次都成功，即使当前工作目录中存在冲突。脚本应该这样：12 #!/bin/bashgit --work-tree=/var/www/html --git-dir=/home/demo/proj/.git checkout -f 这时，我们已经几乎完成了。然而，我们需要更仔细查看每次post-commit钩子运行时的环境变量。尤其是GIT_INDEX_FILE被设置成.git/index。 这个路径与工作目录相关，在我们的例子中是/var/www/html。由于git的index文件不存在，脚本会失效，如果我们保留当前的设置。为了避免这种情况，我们可以手动设置这个变量，这将导致git相对于仓库目录去搜索。我们需要在脚本中的checkout之前添加一行:123 #!/bin/bashunset GIT_INDEX_FILEgit --work-tree=/var/www/html --git-dir=/home/demo/proj/.git checkout -f 这些冲突正是git钩子出的问题经常很难诊断的原因。你必须清楚git是怎么构建它的运行环境的。 当你编辑结束后，保存并退出这个文件。 因为这是一个常规的脚本文件，我们需要让它有可执行权限：1chmod +x .git/hooks/post-commit 现在，我们最终准备好在我们的git仓库中提交变更。确保你退到了正确的目录，并且提交这些变更：12cd ~/projgit commit -m \"here we go...\" 现在，如果你使用浏览器访问服务器的域名或者IP地址，你讲看到你刚刚创建的这个index.html文件：1http://server_domain_or_IP 正如你所见，我们最近的变更在提交之后被自动的推送到了服务器根目录下。我们可以再做一些改变来证明，钩子在每次提交之后都正确工作了。123echo \"&lt;p&gt;Here is a change.&lt;/p&gt;\" &gt;&gt; index.htmlgit add .git commit -m \"First change\" 当我们刷新浏览器，我们可以直接看到新的变化： 如你所见，这种配置比较方便本地测试，然而，你可能永远不希望在生产环境中这样提交。还是在经过测试后确保没问题了再提交，这样比较安全。 利用Git钩子在另外的生产环境中部署在第二个例子中，我们将要示范一个更新生产服务器更好的方式。我们可以通过使用push-to-deploy模型以便当我们推送到裸仓库时更新我们的web服务器。 我们可以沿用上面的服务器当作开发机。这是我们做改动工作的地方。我们可以在每次提交之后看到改变。 在我们的生产机器上，我们将会配置另一个web服务器，一个裸的仓库用来推送我们的变更，还有一个git钩子在每次接受到推送都会执行。以普通用户身份，用sudo，完成系列步骤。 建立生产环境的post-receive钩子现在生产环境中安装web服务器：12sudo apt-get updatesudo apt-get install apache2 然后，我们再更改目录拥有者给当前用户：1sudo chown -R `whoami`:`id -gn` /var/www/html 我们还需要在服务器上安装git：1sudo apt-get install git 现在我们可以在home目录下创建一个目录，来存放我们的仓库。然后我们进入这个目录来初始化一个裸的仓库。裸仓库不包含工作目录，这对于服务器来说更好，因为我们不在上面直接工作：123mkdir ~/projcd ~/projgit init --bare 这是一个裸仓库，所以没有工作目录并且所有文件都在.git文件夹下，该文件夹通常在根目录下。 我们需要创建另一个git钩子，这一次，我们感兴趣的是post-receive钩子，它是在服务器端接收到git push时执行。在编辑器中打开这个文件：1nano hooks/post-receive 在脚本的开始，我们需要指定我们脚本的类型，然后我们可以写和post-commit一样的checkout命令，修改成这台机器使用的目录：12 #!/bin/bashgit --work-tree=/var/www/html --git-dir=/home/demo/proj checkout -f 由于这是一个裸仓库，--git-dir应该指向仓库目录的顶层。其它都和之前一样。 然后，我们需要在脚本里增加一些额外的逻辑。如果我们不小心推送了test-feature分支到服务器上，我们不希望它被部署。我们想确保只部署master分支。 关于post-receive钩子，你在之前的表格里可能已经注意到，git传递旧版本的提交hash，新版本的提交hash还有作为标准输入到脚本被推送的引用。我们可以通过它检查，该引用是否为master分支。 首先我们需要读取这个标注输入。每一个被推送的引用，它的三部分信息（旧版本，新版本，引用）被提供给脚本，作为标准输入，之间用空格分开。我们可以用一个while循环包住这条git命令。12345 #!/bin/bashwhile read oldrev newrev refdo git --work-tree=/var/www/html --git-dir=/home/demo/proj checkout -fdone 现在，我们将根据你被提交的内容产生了3个变量。对于master分支的推送，ref对象将包含像是refs/heads/master的东西。我们可以通过使用if检查一下服务器接收到的ref是否为这种格式： 12345678#!/bin/bashwhile read oldrev newrev refdo if [[ $ref =~ .*/master$ ]]; then git --work-tree=/var/www/html --git-dir=/home/demo/proj checkout -f fidone 对于服务器端的钩子，git实际上可以将信息传回客户端。任何发送到标准输出的东西都会跳转到客户端。这给了我们机会显式通知用户做了什么样的决策。 我们应该增加一些文字，描述我们检测到的情况，和我们执行的动作。我们应该添加一个else代码，在一个非master分支被成功接收时通知用户，即使这个动作并不触发部署：1234567891011 #!/bin/bashwhile read oldrev newrev refdo if [[ $ref =~ .*/master$ ]]; then echo \"Master ref received. Deploying master branch to production...\" git --work-tree=/var/www/html --git-dir=/home/demo/proj checkout -f else echo \"Ref $ref successfully received. Doing nothing: only the master branch may be deployed on this server.\" fidone 结束之后，保存并关闭这个文件。 切记，我们必须给这个脚本可执行的权限。 1chmod +x hooks/post-receive 现在我们可以在我们本地对这个远程服务器建立访问了。 在本地机器上配置远程服务器回到我们的本地机器（开发机）,进入我们项目的工作目录：1cd ~/proj 在文件夹内，添加远程服务器，命名为production。你需要知道声场服务器的用户名，IP地址或者域名。你还需要知道你裸仓库对于home目录的相对路径。 你输入的命令应该是大体这个样子：1git remote add production demo@server_domain_or_IP:proj 现在我们推送我们本地分支到生产服务器：1git push production master 如果你没配置SSH的key，那你可能必须输入生产服务器的用户密码。你会看到类似下面的显示：12345678Counting objects: 8, done.Delta compression using up to 2 threads.Compressing objects: 100% (3/3), done.Writing objects: 100% (4/4), 473 bytes | 0 bytes/s, done.Total 4 (delta 0), reused 0 (delta 0)remote: Master ref received. Deploying master branch...To demo@107.170.14.32:proj 009183f..f1b9027 master -&gt; master 如你所见，来自我们post-receive钩子的文本出现在命令行的输出中。如果我们使用浏览器访问我们生产服务器的域名或者IP地址，我们可以看到我们项目的当前版本： 看起来钩子收到信息时成功将我们的代码推送到生产服务器。 现在，让我们测试我们的新代码。回到开发机上，我们将创建一个新分支并进行一些改变。这样，我们可以确保在我们部署到生产环境之前，一切就绪。 建立一个叫\u0006test_feature的新分支，然后checkout：1git checkout -b test_feature 我们现在处于test_feature分支中，让我们做一些改变，稍后推送到生产服务器中。我们将提交到这个分支中：123echo \"&lt;h2&gt;New Feature Here&lt;/h2&gt;\" &gt;&gt; index.htmlgit add .git commit -m \"Trying out new feature\" 这时候，如果你访问开发机的IP地址或者域名，你将看到你的做的修改。 这是因为开发机仍在每次提交后部署。这个工作流很棒，它可以让我们在部署生产环境之前测试我们的修改。 我们可以推送我们的test_feature分支到远程生产服务器：1git push production test_feature 在post-receive钩子的输出中应该有其它的信息：12345678Counting objects: 5, done.Delta compression using up to 2 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 301 bytes | 0 bytes/s, done.Total 3 (delta 1), reused 0 (delta 0)remote: Ref refs/heads/test_feature successfully received. Doing nothing: only the master branch may be deployed on this serverTo demo@107.170.14.32:proj 83e9dc4..5617b50 test_feature -&gt; test_feature 如果我们在浏览器中查看生产服务器，你将看到什么都没有改变。这就是我们所希望的，因为我们的改变不在master分支中。 现在我们已经在开发机器上测试了我们的修改，我们确定要合并这个修改到master分支上。我们可以checkout到master分支，然后在开发机上mergetest_feature分支。 12git checkout mastergit merge test_feature 现在，你已经将新分支合并到主分支。推送到生产服务器将部署这个修改：1git push production master 如果我们在浏览器查看生产服务器，我们将看到我们的改变： 使用这个工作流，我们可以在开发机上直接显示提交的修改。生产机器只在master分支被推送时候被更新。 结论如果你跟着我的步骤做完，你应该已经了解了git钩子有多种方法将我们一部分工作自动化。它们可以帮你部署代码，可以通过拒绝不符合要求的修改和提交，来控制代码质量。 然而，git钩子的效用很难讨论，它实际的实现非常复杂。练习实现多种配置，试验解析参数，标准输入，跟踪git如何构建钩子的环境将会带你慢慢了解如何写有效的钩子脚本。从长远上看，时间的投入通常是值得的，它可以很简单的节省你和你团队在项目工作中很多手动操作的负担。","raw":null,"content":null,"categories":[{"name":"服务器上那点事儿","slug":"服务器上那点事儿","permalink":"http://lioil.thisteam.cn/categories/服务器上那点事儿/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://lioil.thisteam.cn/tags/Git/"},{"name":"hook","slug":"hook","permalink":"http://lioil.thisteam.cn/tags/hook/"}]}]}